(in-package :colitrsynth)

;;;; 処理の都合上必要なこ
(defvar *pattern-scroll-lock* nil)

(defconstant +column-width+ 7)

(defmethod initialize-instance :after ((self pattern-module) &key)
  (let* ((pattern-editor (.pattern-editor self))
         (octave (make-instance 'label
                                :value (lambda ()
                                         (format nil "~d" (.octave pattern-editor)))
                                :x (- (.width self) (* *char-width* 4) *layout-space*)
                                :y *layout-space*))
         (edit-step (make-instance 'label
                                   :value (lambda ()
                                            (format nil "~2,'0d" (.edit-step pattern-editor)))
                                   :x (- (.width self) (* *char-width* 2) *layout-space*)
                                   :y *layout-space*)))
    (add-child self pattern-editor)
    (add-child self octave)
    (add-child self edit-step)
    (setf (.pattern pattern-editor) self
          (.x pattern-editor) *layout-space*
          (.y pattern-editor) (+ *font-size* (* *layout-space* 2))
          (.width pattern-editor) (- (.width self) 10)
          (.height pattern-editor) (- (.height self) (+ 15 *font-size*)))))

(defmethod (setf .cursor-y) :after (value (self pattern-editor))
  (setf (.offset-y self)
        (round (- (* *char-height* (+ value 0.7)) ;なんで 0.7?
                  (/ (.height self) 2)))))

;; TODO もしかすると resized に移すべき？
(defmethod render :before ((self pattern-editor) renderer)
  (when (and (.playing *audio*)
             (not *pattern-scroll-lock*))
    (setf (.cursor-y self) (.current-line (.pattern self))))
  (let ((pattern-lines (.lines (.pattern self))))
    (if (/= (length pattern-lines)
            (length (.lines self)))
        (progn
          (loop for line in (.lines self)
                do (remove-child self line))
          (setf (.lines self) nil)
          (loop for pattern-line across pattern-lines
                for y from 2 by *char-height*
                for line = (make-instance 'pattern-editor-line :line pattern-line
                                                               :x 3 :y y)
                do (push line (.lines self))
                   (add-child self line))
          (setf (.lines self) (nreverse (.lines self))))
        ;; PERFORMANCE 毎回やる必要ないよね
        (loop for pattern-line across pattern-lines
              for pattern-editor-line in (.lines self)
              do (setf (.line pattern-editor-line) pattern-line)))))

(defmethod render ((self pattern-editor) renderer)
  (call-next-method)
  (when (.focused self)
    (apply #'sdl2:set-render-draw-color renderer *focused-color*)
    (sdl2:render-draw-rect renderer
                           (sdl2:make-rect (.render-x self)
                                           (.render-y self)
                                           (.width self)
                                           (.height self)))))

(defmethod keydown ((self pattern-editor) value scancode mod-value)
  (unless (.focused self)
    (return-from keydown 'call-next-method))
  (let* ((shift-p (not (zerop (logand mod-value sdl2-ffi:+kmod-shift+))))
         (ctrl-p (not (zerop (logand mod-value sdl2-ffi:+kmod-ctrl+))))
         (max-cursor-y (1- (length (.lines (.pattern self)))))
         (lines (.lines (.pattern self)))
         (line (aref lines (.cursor-y self)))
         (max-line-length 16)
         (cursor-x (.cursor-x self))
         (column-width 7))
    (labels ((on-note ()
               (zerop (mod cursor-x +column-width+)))
             (set-note (note)
               (when (on-note)
                 (setf (.note (aref (.columns line) (floor (/ cursor-x +column-width+)))) note)
                 (if shift-p
                     (let* ((new-column (1+ (floor cursor-x column-width))))
                       (setf (.shifting-p self) t)
                       (when (< new-column max-line-length)
                         (when (<= (.length line) new-column)
                           (extend-column (.pattern self)))
                         (setf (.cursor-x self) (* new-column column-width))
                         (let ((root (.root-parent self)))
                           (setf (.width root) (max (.width root)
                                                    (* *char-width*
                                                       (+ (* new-column column-width)
                                                          12))))))) ;12は適当
                     (step-next self))))
             (set-velocity (velocity)
               (case (mod cursor-x +column-width+)
                 (4 (set-velocity-x0 velocity))
                 (5 (set-velocity-0x velocity))))
             (set-velocity-x0 (velocity)
               (when (<= velocity 7)
                 (let* ((column (aref (.columns line) (floor (/ cursor-x +column-width+)))))
                   (setf (.velocity column)
                         (+ (* velocity #x10)
                            (mod (.velocity column) #x10))))
                 (step-next self)))
             (set-velocity-0x (velocity)
               (let ((column (aref (.columns line) (floor (/ cursor-x +column-width+)))))
                 (setf (.velocity column)
                       (+ (logand (.velocity column) #xf0)
                          velocity)))
               (step-next self)))
      (cond ((sdl2:scancode= scancode :scancode-f9)
             (setf (.cursor-y self) 0))
            ((sdl2:scancode= scancode :scancode-f10)
             (setf (.cursor-y self) (floor (* (.length (.pattern self)) 1/4))))
            ((sdl2:scancode= scancode :scancode-f11)
             (setf (.cursor-y self) (floor (* (.length (.pattern self)) 2/4))))
            ((sdl2:scancode= scancode :scancode-f12)
             (setf (.cursor-y self) (floor (* (.length (.pattern self)) 3/4))))
            ((or (sdl2:scancode= scancode :scancode-up)
                 (sdl2:scancode= scancode :scancode-k))
             (when (minusp (decf (.cursor-y self)))
               (setf (.cursor-y self) max-cursor-y)))
            ((or (sdl2:scancode= scancode :scancode-down)
                 (sdl2:scancode= scancode :scancode-j))
             (when (< max-cursor-y (incf (.cursor-y self)))
               (setf (.cursor-y self) 0)))
            ((and (or (sdl2:scancode= scancode :scancode-left)
                      (sdl2:scancode= scancode :scancode-h))
                  ctrl-p shift-p)
             (loop with length = (max 1 (1- (.length line)))
                   for line across lines
                   do (setf (.length line) length)))
            ((or (sdl2:scancode= scancode :scancode-left)
                 (sdl2:scancode= scancode :scancode-h))
             (let* ((value (- cursor-x (case (mod cursor-x +column-width+)
                                         (0 2)
                                         (4 4)
                                         (5 1)
                                         (t 0)))))
               (when (<= 0 value)
                 (setf (.cursor-x self) value))))
            ((and (or (sdl2:scancode= scancode :scancode-right)
                      (sdl2:scancode= scancode :scancode-l))
                  ctrl-p shift-p)
             (extend-column (.pattern self)))
            ((or (sdl2:scancode= scancode :scancode-right)
                 (sdl2:scancode= scancode :scancode-l))
             (let* ((value (+ cursor-x (case (mod cursor-x column-width)
                                         (0 4)
                                         (4 1)
                                         (5 2)
                                         (t 0)))))
               (when (< value (* column-width (.length line)))
                 (setf (.cursor-x self) value))))
            ((sdl2:scancode= scancode :scancode-0)
             (set-note (+ d#1 (* 12 (.octave self))))
             (set-velocity 0))
            ((sdl2:scancode= scancode :scancode-1)
             (cond (ctrl-p
                    (when (< 0 (.octave self))
                      (decf (.octave self))))
                   (t (set-velocity 1))))
            ((and (sdl2:scancode= scancode :scancode-2) ctrl-p)
             (when (< (.octave self) 9)
               (incf (.octave self))))
            ((sdl2:scancode= scancode :scancode-2)
             (set-note (+ c#0 (* 12 (.octave self))))
             (set-velocity 2))
            ((and (sdl2:scancode= scancode :scancode-3) ctrl-p shift-p)
             (when (< 0 (.edit-step self))
               (decf (.edit-step self))))
            ((and (sdl2:scancode= scancode :scancode-3) ctrl-p)
             (setf (.edit-step self) (floor (/ (.edit-step self) 2))))
            ((sdl2:scancode= scancode :scancode-3)
             (set-note (+ d#0 (* 12 (.octave self))))
             (set-velocity 3))
            ((and (sdl2:scancode= scancode :scancode-4) ctrl-p shift-p)
             (incf (.edit-step self)))
            ((and (sdl2:scancode= scancode :scancode-4) ctrl-p)
             (setf (.edit-step self)
                   (if (zerop (.edit-step self))
                       1
                       (* (.edit-step self) 2))))
            ((and (sdl2:scancode= scancode :scancode-4))
             (set-velocity 4))
            ((sdl2:scancode= scancode :scancode-5)
             (set-note (+ f#0 (* 12 (.octave self))))
             (set-velocity 5))
            ((sdl2:scancode= scancode :scancode-6)
             (set-note (+ g#0 (* 12 (.octave self))))
             (set-velocity 6))
            ((sdl2:scancode= scancode :scancode-7)
             (set-note (+ a#0 (* 12 (.octave self))))
             (set-velocity 7))
            ((sdl2:scancode= scancode :scancode-8)
             (set-velocity 8))
            ((sdl2:scancode= scancode :scancode-9)
             (set-note (+ c#1 (* 12 (.octave self))))
             (set-velocity 9))            
            ((sdl2:scancode= scancode :scancode-a)
             (set-note off)
             (set-velocity #x0a))
            ((sdl2:scancode= scancode :scancode-b)
             (set-velocity #x0b))
            ((sdl2:scancode= scancode :scancode-c)
             (set-velocity #x0c))
            ((sdl2:scancode= scancode :scancode-d)
             (set-velocity #x0d))
            ((sdl2:scancode= scancode :scancode-e)
             (set-note (+ e0 (* 12 (.octave self))))
             (set-velocity #x0e))
            ((sdl2:scancode= scancode :scancode-f)
             (set-velocity #x0f))
            ((sdl2:scancode= scancode :scancode-q)
             (set-note (+ c0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-w)
             (set-note (+ d0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-r)
             (set-note (+ f0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-t)
             (set-note (+ g0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-y)
             (set-note (+ a0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-u)
             (set-note (+ b0 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-i)
             (set-note (+ c1 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-o)
             (set-note (+ d1 (* 12 (.octave self)))))
            ((sdl2:scancode= scancode :scancode-p)
             (set-note (+ e1 (* 12 (.octave self)))))
            ((= scancode 47)             ;@
             (set-note (+ f1 (* 12 (.octave self)))))
            ((= scancode 46)             ;^
             (set-note (+ f#1 (* 12 (.octave self)))))
            ((= scancode 48)             ;[
             (set-note (+ g1 (* 12 (.octave self)))))
            ((= scancode 137)            ;\
             (set-note (+ g#1 (* 12 (.octave self)))))
            ((and (sdl2:scancode= scancode :scancode-delete)
                  (or (not shift-p) (not ctrl-p)))
             (set-note none))
            (t
             (call-next-method)
             ;; TODO ちょっとわけわからんことになっているので何とかしたいです
             ;; ohandle-sdl2-keydown-event から (.focused-view *app*) で直に来ているから
             'call-next-method)))))

(defmethod keyup ((self pattern-editor) value scancode mod-value)
  (cond ((and (.shifting-p self)
              (or (sdl2:scancode= scancode :scancode-lshift)
                  (sdl2:scancode= scancode :scancode-rshift)))
         (setf (.shifting-p self) nil)
         (step-next self)
         (setf (.cursor-x self) 0))
        (t (call-next-method))))

(defmethod step-next ((self pattern-editor))
  (setf (.cursor-y self) (mod (+ (.cursor-y self) (.edit-step self))
                              (length (.lines (.pattern self))))))


(defmethod render :before ((self pattern-editor-line) renderer)
  (let* ((parent (.parent self))
         (position (position self (.lines parent))))
    (setf (.value self)
          (with-output-to-string (out)
            (format out "~2,'0X" position)
            (loop with line = (.line self)
                  repeat (.length line)
                  for column across (.columns line)
                  for note = (.note column)
                  do (cond ((= note off)
                            (write-string " OFF --" out))
                           ((= note none)
                            (write-string " --- --" out))
                           (t
                            (let* ((c-s-o (format nil "~a" (midino-to-note note)))
                                   (c (char c-s-o 0))
                                   (s (if (char= (char c-s-o 1) #\#)
                                          #\#
                                          #\-))
                                   (o (char c-s-o (if (char= s #\#) 2 1))))
                              (format out " ~c~c~c ~2,'0X"
                                      c s o (.velocity column))))))))
    ;; play position
    (when (= (.current-line (.pattern parent)) position)
      (apply #'sdl2:set-render-draw-color renderer *play-position-color*)
      (let ((play-x (.render-x self))
            (play-y (.render-y self))
            (play-w (.width self))
            (play-h *char-height*))
        (sdl2:render-fill-rect
         renderer (sdl2:make-rect play-x play-y play-w play-h))))
    ;; cursor
    (when (and (.focused parent)
               (= (.cursor-y parent) position))
      (apply #'sdl2:set-render-draw-color renderer *cursor-color*)
      (let ((cursor-x (* *char-width* (+ (.cursor-x parent) 3)))
            (cursor-y (.render-y self))
            (cursor-w (if (zerop (mod (.cursor-x parent) +column-width+))
                          (* *char-width* 3)
                          *char-width*))
            (cursor-h *char-height*))
        (sdl2:render-fill-rect
         renderer (sdl2:make-rect cursor-x cursor-y cursor-w cursor-h))))))

(defmethod close ((self pattern-module) &key abort)
  (declare (ignore abort))
  (loop for track-view in (.tracks *sequencer-module*)
        do (loop for pattern-position-view in (.children track-view)
                 if (and (typep pattern-position-view 'pattern-position-view)
                         (eql self
                              (.pattern pattern-position-view)))
                   do (remove-pattern track-view pattern-position-view))))

(defmethod mousebuttondown :before ((self pattern-module) button state clicks x y)
  (setf (.selected-pattern *app*) self))

(defmethod keydown ((self pattern-module) value scancode mod-value)
  ;; TODO pattern-editor にフォーカスしている場合の pattern-editor の keydown をコールする
  (when (eq 'call-next-method
            (keydown (.pattern-editor self) value scancode mod-value))
    (call-next-method)))

(defmethod (setf .width) :after (value (self pattern-module))
  (setf (.width (.pattern-editor self)) (- (.width self) 10)))

(defmethod (setf .height) :after (value (self pattern-module))
  (setf (.height (.pattern-editor self)) (- (.height self) (+ 10 *font-size*))))

(defmethod serialize ((self pattern-module))
  `((setf (.length x) ,(.length self)
          (.lines x) ,(serialize (.lines self))
          (.current-line x) 0)
    (setf (.octave (.pattern-editor x)) ,(.octave (.pattern-editor self))
          (.edit-step (.pattern-editor x)) ,(.edit-step (.pattern-editor self)))
    ,@(call-next-method)))

(defmethod serialize ((self line))
  `(make-instance 'line
                  :columns ,(serialize (.columns self))
                  :lenght ,(.length self)))

(defmethod serialize ((self column))
  `(make-instance 'column
                  :note ,(.note self)
                  :velocity ,(.velocity self)))
